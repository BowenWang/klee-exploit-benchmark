/* A simple server in the internet domain using TCP
   The port number is passed as an argument */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h> 
#include <sys/socket.h>
#include <netinet/in.h>

#define htonll(x) ((1==htonl(1)) ? (x) : ((uint64_t)htonl((x) & 0xFFFFFFFF) << 32) | htonl((x) >> 32))
#define ntohll(x) ((1==ntohl(1)) ? (x) : ((uint64_t)ntohl((x) & 0xFFFFFFFF) << 32) | ntohl((x) >> 32))

// We need three elements in the array
// element 0: specify the heap operation type
// element 1: the first argument
// element 2: the second argument
// ssize_t
#define REQUEST_LEN 3
#define MESSAGE_LEN 1
struct memory_op{
    long type;
    long arg1;
    long arg2;
};
typedef struct memory_op memory_op;

void error(const char *msg)
{
    perror(msg);
    exit(1);
}

int main(int argc, char *argv[])
{
     int sockfd, newsockfd, portno;
     socklen_t clilen;
     //size_t buffer[MESSAGE_LEN];
     memory_op read_memory_op;
     bzero(&read_memory_op, sizeof(read_memory_op));
     struct sockaddr_in serv_addr, cli_addr;
     int n;
     if (argc < 2) {
         fprintf(stderr,"ERROR, no port provided\n");
         exit(1);
     }
     sockfd = socket(AF_INET, SOCK_STREAM, 0);
     if (sockfd < 0) 
        error("ERROR opening socket");
     bzero((char *) &serv_addr, sizeof(serv_addr));
     portno = atoi(argv[1]);
     serv_addr.sin_family = AF_INET;
     serv_addr.sin_addr.s_addr = INADDR_ANY;
     serv_addr.sin_port = htons(portno);
     if (bind(sockfd, (struct sockaddr *) &serv_addr,
              sizeof(serv_addr)) < 0) 
              error("ERROR on binding");
     listen(sockfd,5);
     while(1){
         clilen = sizeof(cli_addr);
         newsockfd = accept(sockfd, 
                     (struct sockaddr *) &cli_addr, 
                     &clilen);
         if (newsockfd < 0) 
              error("ERROR on accept");
         //bzero(buffer, MESSAGE_LEN * (sizeof(size_t)));
         bzero(&read_memory_op, sizeof(read_memory_op));
         printf("size of %d\n", sizeof(memory_op));
         n = read(newsockfd, &read_memory_op, sizeof(memory_op));
         if (n < 0) error("ERROR reading from socket");
         printf("number of bytes read: %d\n", n);
         //printf("Here is the message: 0x%lx\n", htonll(buffer[0]));
         //read_memory_op.type = ntohll(read_memory_op.type);
         //read_memory_op.arg1 = ntohll(read_memory_op.arg1);
         //read_memory_op.arg2 = ntohll(read_memory_op.arg2);
         read_memory_op.type = be64toh(read_memory_op.type);
         read_memory_op.arg1 = be64toh(read_memory_op.arg1);
         read_memory_op.arg2 = be64toh(read_memory_op.arg2);


         printf("type of heap operation: %c\n", read_memory_op.type);
         printf("first argument:  0x%lx\n", read_memory_op.arg1);
         printf("second argument: 0x%lx\n", read_memory_op.arg2);
         // do malloc
         //void *p = malloc(ntohll(buffer[0]));
         void *p = NULL;
         size_t buffer[MESSAGE_LEN];
         //n = write(newsockfd,"I got your message",18);
         // 16+1+1+4
         char replay_message[100];
         int final_number_to_send = snprintf(replay_message, 100, "Your pointer: 0x%x\n", p);
         //n = write(newsockfd,"Your pointer: 0x%x\n",18);
         n = write(newsockfd, replay_message, final_number_to_send+1);
         if (n < 0) error("ERROR writing to socket");
         close(newsockfd);
     }
     close(sockfd);
     return 0; 
}
