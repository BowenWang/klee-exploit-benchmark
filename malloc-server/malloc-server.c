#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <string.h>

// We don't need a CALLOC_OP since KLEE handles calloc() function calls
// based on its malloc handling code
#define MALLOC_OP (size_t)'m'
#define FREE_OP (size_t)'f'
#define REALLOC_OP (size_t)'r'

struct memory_op{
    size_t type;
    size_t arg1;
    size_t arg2;
};
typedef struct memory_op memory_op;

// for malloc and realloc, 
struct heapop_retval{
    // for malloc and realloc, return the allocated pointer
    // for free, just return -1.
    // can't think of anything else for now, but may add something later into
    // this struct
    size_t ret_ptr;
};
typedef struct heapop_retval heapop_retval;

int main(int argc, char *argv[])
{
    int socket_fd = atoi(argv[1]);
    printf("in malloc server, socket_fd: %d\n", socket_fd);
    memory_op recv_heapop;
    heapop_retval heapop_return;
    while(1){
        memset(&recv_heapop, 0, sizeof(memory_op));
        memset(&heapop_return, 0, sizeof(heapop_retval));
        read(socket_fd, &recv_heapop, sizeof(memory_op));
        printf("from child, type: %c, arg1: 0x%lx, arg2: 0x%lx\n", (char)recv_heapop.type, recv_heapop.arg1, recv_heapop.arg2);
        if(recv_heapop.type == MALLOC_OP){
            void *p = malloc(recv_heapop.arg1);
            heapop_return.ret_ptr = (size_t)p;
        }else if(recv_heapop.type == REALLOC_OP){
            //void *p = (void *)recv_heapop.arg1;
            void *p = realloc((void *)recv_heapop.arg1, (size_t)recv_heapop.arg2);
            heapop_return.ret_ptr = (size_t)p;
        }else if(recv_heapop.type == FREE_OP){
            free((void *)recv_heapop.arg1);
            heapop_return.ret_ptr = 0ULL;
        }
        write(socket_fd, &heapop_return, sizeof(heapop_retval));
    }

    return 0;
}
