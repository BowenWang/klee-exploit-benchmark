#include "klee/MallocServer/MallocServer.h"
#include "llvm/Support/raw_ostream.h"
//#include <iostream>
using namespace llvm;
#define MALLOC_OP (size_t)'m'
#define FREE_OP (size_t)'f'
#define REALLOC_OP (size_t)'r'


MallocServer globalMallocServer;
/*
class MallocServer{
public:
  int socketfds[2];
  std::string MallocServerExecPath;
  MallocServer();
  ~MallocServer();  // deconstructor
  void InitSockets();
  void InvokeMallocServer();
  void *SendMallocRequest(size_t size);
  void SendFreeRequest(size_t ptr_addr);
  void *SendReallocRequest(size_t ptr_addr, size_t new_size);
};
*/
MallocServer::MallocServer() {
  // there isn't really anything to do in this version of the construction
  this->MallocServerExecPath = "";
}
// I guess we don't need a deconstructor?
void MallocServer::InitSockets() {
  if (socketpair(AF_UNIX, SOCK_STREAM, 0, this->socketfds) == -1) {
      perror("socketpair");
      exit(1);
  }
}

int MallocServer::InvokeMallocServer(std::string ExecPathFromCLI) {
  this->MallocServerExecPath = ExecPathFromCLI;
  int RetVal = fork();
  if (RetVal == 0){
    // Child process invoke here
    char socket_fd_for_child[8];
    sprintf(socket_fd_for_child, "%d", socketfds[1]);
    char malloc_server_exec_path[512];
    strcpy(malloc_server_exec_path, MallocServerExecPath.c_str());
    char *malloc_server_argv[] = {malloc_server_exec_path, socket_fd_for_child, NULL};
    execv(malloc_server_exec_path, malloc_server_argv);
    exit(0);
  }

  // in the parent process, we still need to return back to the main function
  return RetVal;
}

int MallocServer::MallocServerHandshake(){
  heapop_req handshake_pack;
  heapop_retval handshake_response;
  memset(&handshake_pack, 0, sizeof(heapop_req));
  memset(&handshake_response, 0, sizeof(heapop_retval));
  handshake_pack.type = 0xffffffffffffffff;
  handshake_pack.arg1 = 0xffffffffffffffff;
  handshake_pack.arg2 = 0xffffffffffffffff;
  write(socketfds[0], &handshake_pack, sizeof(heapop_req));
  read(socketfds[0], &handshake_response, sizeof(heapop_retval));
  if(handshake_response.ret_ptr != 0xffffffffffffffff){
    return -1;
  }

  return 0;
}

size_t MallocServer::SendMallocRequest(size_t size){
  heapop_req malloc_request;
  heapop_retval malloc_response;
  memset(&malloc_request, 0, sizeof(heapop_req));
  memset(&malloc_response, 0, sizeof(heapop_retval));
  malloc_request.type = MALLOC_OP;
  malloc_request.arg1 = size;
  malloc_request.arg2 = 0ULL;
  write(socketfds[0], &malloc_request, sizeof(heapop_req));
  read(socketfds[0], &malloc_response, sizeof(heapop_retval));
  //llvm::outs()<<"I got "<<malloc_response.ret_ptr
  return malloc_response.ret_ptr;
}

void MallocServer::SendFreeRequest(size_t ptr_addr){
  heapop_req malloc_request;
  heapop_retval malloc_response;
  memset(&malloc_request, 0, sizeof(heapop_req));
  memset(&malloc_response, 0, sizeof(heapop_retval));
  malloc_request.type = FREE_OP;
  malloc_request.arg1 = ptr_addr;
  malloc_request.arg2 = 0ULL;
  write(socketfds[0], &malloc_request, sizeof(heapop_req));
  read(socketfds[0], &malloc_response, sizeof(heapop_retval));

  return;
}

size_t MallocServer::SendReallocRequest(size_t ptr_addr, size_t new_size){
  // TODO Implement this function after malloc and free
  return 0;
}

